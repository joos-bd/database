# database
Database

**Реляционная модель**

- Реляционная модель представляет собой фиксированную структуру математических понятий, которая описывает, как будут представлены данные;
- Базовой единицей данных в пределах реляционной модели является таблица;
- Таблица — это базовая единица данных. В реляционной алгебре она называется «отношение» (relation). Состоит из атрибутов (columns), которые определяют конкретные типы данных. Данные в таблице организованы в кортежи (rows), которые содержат множества значений столбцов.

**Преимущества:**
- Эффективное поддержание целостности данных;
- Блокировка и очередность доступа к данным;
- Атомарность данных (возможность использования сложных типов данных);
- Поддержка процедурных языков;
- Независимость физической и логической моделей.

Реляционная модель данных — созданная Эдгаром Коддом логическая модель данных, описывающая:
- структуры данных в виде наборов отношений;
- теоретико-множественные операции над данными: объединение, пересечение разность и декартово произведение;
- специальные реляционные операции: селекция, проекция, соединение и деление;
- специальные правила, обеспечивающие целостность данных.

**Ограничения**

**Первичные ключи** - При создании таблицы могут быть использованы различные «ограничения» (CONSTRAINTS), которые содержат правила, указывающие, какие данные представлены в ней. Одним из самых используемых ограничений является первичный ключ (PRIMARY KEY), который гарантирует, что каждая строка таблицы содержит уникальный идентификатор. Правильным считается наличие первичного ключа во всех таблицах базы данных. PRIMARY KEY = UNIQUE + NOT NULL + INDEX

Первичный ключ может состоять из одного или нескольких столбцов. Первичные ключи, состоящие из нескольких столбцов называются «составными» (COMPOSITE).

**Натуральные первичные ключи** - Представляют собой данные, которые уже присутствуют в описываемой предметной области. Например, почтовые индексы могут быть использованы как естественные первичные ключи без дополнительной обработки. Их использование, если оно возможно, считается более правильным, чем искусственных. В справочнике стран натуральным первичным ключом может быть ISO код стран. В справочнике граждан РФ натуральным составным первичным ключом может быть серия и номер паспорта.

**Суррогатные первичные ключи** - Представляют собой целочисленный идентификатор. Применяется там, где нет возможности использовать натуральный первичный ключ. Позволяют решать те же практические задачи, что и естественные: улучшение производительности памяти и индексов при операциях обновления.

**Внешние ключи** - В то время как одна таблица имеет первичный ключ, другая таблица может иметь ограничение, описывающее, что её значения ссылаются на гарантированно существующие значения в первой таблице. Это реализуется через создание в «дочерней» таблице столбца (может быть несколько столбцов), значениями которого являются значения первичного ключа из «родительской» таблицы.

Вместе наборы этих столбцов составляют внешний ключ (FOREIGN KEY), который является механизмом базы данных, гарантирующим, что значения в «дочерних» столбцах присутствуют как первичные ключи в «родительских».
Это ограничение контролирует все операции на этих таблицах:
- добавление / изменение данных в «дочерней» таблице
- удаление / изменение данных в «родительской» таблице.
Внешний ключ проверяет, чтобы данные корректно присутствовали в обеих таблицах. Иначе операции будут отменены.

Внешние ключи могут быть составными. Как правило «родителем» во внешнем ключе является первичный ключ, но при необходимости «родителем» может быть любой столбец, который имеет ограничение уникальности (UNIQUE).

**UNIQUE**

Ограничение UNIQUE:
- гарантирует, что все значения в столбце будут уникальными.
- может быть наложено на один или несколько столбцов.
В каждой таблице может быть несколько уникальных ограничений. Ограничение первичного ключа имеет ограничение UNIQUE по умолчанию.

**NOT NULL**

Изначально столбец в таблице может содержать любые значения, включая «нулевые» значения, то есть пустые значения. Ограничение NOT NULL делает так, что в столбец нельзя записать «нулевые» значения. Таким образом, поле всегда будет содержать значение и при попытке внести пустое значение при добавлении или изменении записи будет выбрасывать ошибку. Ограничение первичного ключа имеет ограничение NOT NULL по умолчанию.

**CHECK**

Ограничение CHECK:
- используется для ограничения диапазона значений, который может быть записан в столбец.
- может быть указано для одного столбца и допускает только определенные значения для этого столбца.
- может быть указано для таблицы, таким образом оно ограничивает значения в определенных столбцах на основе значений в других столбцах строки.

**Нормализация**

**Нормализация** — это метод проектирования базы данных, который используется для разработки таблицы реляционной базы данных до более высокой нормальной формы. При этом данный процесс является прогрессивным, и более высокий уровень нормализации базы данных не может быть достигнут, если не были выполнены предыдущие уровни.

**1 нормальная форма**

Чтобы таблица удовлетворяла 1НФ, значения в каждом столбце должны быть атомарными. То есть, значения в домене каждого атрибута отношения не являются ни списками, ни множествами простых или сложных значений. Столбцы purchases и wish_list хранят множества данных, а в столбце customer_address можно выделить город проживания.

**2 нормальная форма**

Таблица обязана соответствовать первой нормальной форме. Все столбцы, которые не являются частью ключа, зависят от этого ключа. Чтобы соответствовать 2НФ и удалить дубликаты, каждый неключевой атрибут должен зависеть от всего ключа, а не только от его части. Можно обратить внимание, как нехорошо выглядит таблица с продажами, надо вносить изменения в структуру продаж и менять первичный ключ.

**3 нормальная форма**

Таблица обязана соответствовать второй нормальной форме. Значения, входящие в запись и не являющиеся частью ключа этой записи, не принадлежат таблице. В таблице customer осталась информация по адресу доставки, которая относится к продажам. Создадим таблицу, в которую будем записывать адреса для доставки и уберем информация из customer.

**Нормальная Форма Бойса-Кодда**

Реляционная схема считается в нормальной форме Бойса-Кодда (НФБК), если для каждой из ее зависимостей A → B выполняется одно из следующих условий:
- A → B является тривиальной функциональной зависимостью (то есть B является подмножеством A);
- A — первичный ключ для схемы реляционной схемы.
То есть, если таблица находится в 3НФ и все ее столбцы являются частью составного первичного ключа, то эта таблица находится в НФБК. НФБК — это расширенная 3НФ. Как правило 3НФ является желаемым результатом и дальнейшая нормализация может приводить к ненужному результату, из-за которого усложняется выборка данных.

**4 нормальная форма**

4 нормальная форма применяется для устранения многозначных зависимостей — таких зависимостей, где столбец с первичным ключом имеет связь один-ко-многим со столбцом, который не является ключом. Эта нормальная форма устраняет некорректные отношения многие-ко-многим.

**5 нормальная форма**

5 нормальная форма разделяет таблицы на более малые таблицы для устранения избыточности данных. Разбиение идет до тех пор, пока нельзя будет воссоздать оригинальную таблицу путем объединения малых таблиц

**Нормализация**

При проектировании базы можно избегать какие-либо формы нормализации. Если изначально есть понимание разделения сущностей и связей по своим местам, то можно пропустить начальные формы нормализации. Также при исправлении нарушений одной нормальной формы можно заранее учесть нарушения более высокой формы. Рассматривать ETNF (основного домена), DKNF (ключа домена), 6 нормальную форму не будем, так как они носят больше научный характер и на практике не применяются.

**Функциональные зависимости**

Функциональные зависимости — это основа нормализации баз данных. Под функциональной зависимостью подразумевается зависимость значения одного атрибута от другого. Если даны два атрибута А и Б некоторого отношения, то говорят, что Б функционально зависит от А, если в любой момент времени каждому значению А соответствует ровно одно значение Б.

**Денормализация**

Денормализация — это процесс ухода от правил нормализации там, где это необходимо. Для процесса денормализации не существует стандартного алгоритма. Процесс денормализации индивидуален и требует четкого понимания, для чего он необходим в связи с появлением избыточности.

К денормализации прибегают для сокращения времени обработки запросов и уменьшения затрат ресурсов. В нормализованных базах часто приходится соединять большое количество таблиц или добавлять агрегацию. Таким образом денормализацию можно выполнить сократив количество таблиц или добавив новые столбцы в существующую таблицу. При этом учитывая избыточность данных необходимо следить за целостностью данных. Процесс денормализации зависит от СУБД в которой происходит работа.

К примеру, в PostgreSQL есть возможность создания материализованных представлений (MATERIALIZED VIEW), то есть можно создать МП, внутри которого будет выполнена логика по соединению данных из нескольких таблиц, произведена агрегация и другие действия, а результат этих действий будет физически храниться на жестком диске. Когда нужно будет актуализировать данные, достаточно обновить данные командой:
```
REFRESH MATERIALIZED VIEW имя_МП
```
Далее при обращении к МП данные будут читаться с диска, а не выполняться вся логика запроса, что сокращает время работы с данными во множество раз.

К примеру, в MySQL нет поддержки МП, здесь можно создать денормализованную таблицу, и с помощью триггерных функций формировать данные в денормализованной таблице. При изменении данных в нормализованных таблицах или при добавлении новых данных в эти таблицы должны отрабатывать триггеры, которые будут вызывать единую хранимую процедуру, которая будет производить необходимые вычисления, соединения данных и полученный результат записывать в денормализованную таблицу. Важно помнить, что при появлении избыточности или дублировании атрибутов необходимо контролировать целостность при внесении и модификации данных.

**Типы данных**

Выделяют следующие типы данных:
- Числовые,
- Строковые,
- Дата и время,
- Сложные, бинарные, геометрические...
При этом в зависимости от СУБД названия и поддержка разных типов данных может отличаться.
